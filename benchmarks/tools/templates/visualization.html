<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>@@TITLE@@</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@sgratzl/chartjs-chart-boxplot@4.2.5/build/index.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: #ffffff;
      color: #333333;
      line-height: 1.5;
      padding: 24px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      margin-bottom: 32px;
      padding-bottom: 16px;
      border-bottom: 1px solid #e0e0e0;
    }

    .header h1 {
      font-size: 24px;
      font-weight: 600;
      color: #1a1a1a;
      margin-bottom: 4px;
    }

    .header p {
      font-size: 14px;
      color: #666666;
    }

    .controls {
      display: flex;
      gap: 16px;
      margin-bottom: 32px;
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .control-group label {
      font-size: 13px;
      font-weight: 500;
      color: #555555;
    }

    .control-group select {
      padding: 8px 12px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      background: #ffffff;
      font-size: 14px;
      color: #333333;
      cursor: pointer;
    }

    .control-group select:hover {
      border-color: #a0a0a0;
    }

    .control-group select:focus {
      outline: none;
      border-color: #4a90e2;
    }

    .section {
      background: #ffffff;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      margin-bottom: 24px;
      padding: 20px;
    }

    .section h2 {
      font-size: 18px;
      font-weight: 600;
      color: #1a1a1a;
      margin-bottom: 16px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 16px;
      margin-bottom: 16px;
    }

    .stat-card {
      padding: 16px;
      background: #f8f8f8;
      border-radius: 4px;
    }

    .stat-card h3 {
      font-size: 12px;
      font-weight: 500;
      color: #666666;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-card .value {
      font-size: 24px;
      font-weight: 600;
      color: #1a1a1a;
    }

    .stat-card .unit {
      font-size: 14px;
      color: #888888;
      margin-left: 4px;
      font-weight: 400;
    }

    .chart-container {
      position: relative;
      height: 400px;
    }

    .chart-container-large {
      position: relative;
      height: 800px;
    }

    .details-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    .details-table th {
      padding: 12px;
      text-align: left;
      font-weight: 600;
      color: #555555;
      border-bottom: 2px solid #e0e0e0;
      font-size: 13px;
      cursor: pointer;
      user-select: none;
    }

    .details-table th:hover {
      background: #f8f8f8;
    }

    .details-table th[data-sort="asc"]::after {
      content: ' ▲';
      color: #4a90e2;
      font-size: 10px;
    }

    .details-table th[data-sort="desc"]::after {
      content: ' ▼';
      color: #4a90e2;
      font-size: 10px;
    }

    .details-table td {
      padding: 10px 12px;
      border-bottom: 1px solid #f0f0f0;
      color: #333333;
    }

    .details-table tbody tr:hover {
      background: #f8f8f8;
    }

    .benchmark-name {
      font-weight: 500;
    }

    .variant-name {
      display: inline-block;
      padding: 4px 8px;
      background: #e8f0fe;
      color: #1967d2;
      border-radius: 3px;
      font-size: 12px;
      font-weight: 500;
    }

    .metric-value {
      font-variant-numeric: tabular-nums;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 52px;
      height: 28px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #d0d0d0;
      transition: 0.3s;
      border-radius: 28px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: #4a90e2;
    }

    input:checked + .toggle-slider:before {
      transform: translateX(24px);
    }

    .toggle-label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #555555;
    }

    footer {
      margin-top: 32px;
      padding-top: 16px;
      border-top: 1px solid #e0e0e0;
      text-align: center;
      font-size: 13px;
      color: #888888;
    }

    @media (max-width: 768px) {
      body {
        padding: 16px;
      }

      .controls {
        flex-direction: column;
      }

      .chart-container {
        height: 300px;
      }

      .stats-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header class="header">
      <h1>@@TITLE@@</h1>
      <p>Benchmark Results</p>
    </header>

    <section class="section">
      <h2>Parallel Speedup - All Benchmarks</h2>
      <div class="chart-container-large">
        <canvas id="overallSpeedupChart"></canvas>
      </div>
    </section>

    <section class="controls">
      <div class="control-group">
        <label for="benchmarkFilter">Benchmark</label>
        <select id="benchmarkFilter"></select>
      </div>
      <div class="control-group">
        <label for="metricType">Metric</label>
        <select id="metricType">
          <option value="real_mean">Real Time (Mean)</option>
          <option value="cpu_mean">CPU Time (Mean)</option>
          <option value="gc_mean">GC Time (Mean)</option>
          <option value="real_min">Real Time (Min)</option>
          <option value="real_max">Real Time (Max)</option>
        </select>
      </div>
      <div class="control-group">
        <label class="toggle-label">
          <span>Logarithmic Scale</span>
          <label class="toggle-switch">
            <input type="checkbox" id="scaleToggle">
            <span class="toggle-slider"></span>
          </label>
        </label>
      </div>
    </section>

    <main>
      <section class="section">
        <h2>Statistics</h2>
        <div class="stats-grid" id="statsGrid"></div>
      </section>

      <section class="section">
        <h2>Execution Time by Worker Count</h2>
        <div class="chart-container">
          <canvas id="benchmarkChart"></canvas>
        </div>
      </section>

      <section class="section">
        <h2>Speedup</h2>
        <div class="chart-container">
          <canvas id="speedupChart"></canvas>
        </div>
      </section>

      <section class="section">
        <h2>Detailed Results</h2>
        <table class="details-table" id="detailsTable">
          <thead>
            <tr>
              <th data-column="benchmark">Benchmark</th>
              <th data-column="variant">Variant</th>
              <th data-column="worker">Workers</th>
              <th data-column="count">Count</th>
              <th data-column="real_mean">Real Mean (ms)</th>
              <th data-column="real_stddev">StdDev (ms)</th>
              <th data-column="real_min">Min (ms)</th>
              <th data-column="real_max">Max (ms)</th>
              <th data-column="cpu_mean">CPU Mean (ms)</th>
              <th data-column="gc_mean">GC Mean (ms)</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>
    </main>

    <footer>
      Generated on <span id="timestamp"></span> · <span id="dataPoints"></span> data points
    </footer>
  </div>

  <script>
    const data = @@DATA@@;
    let timingChart = null;
    let speedupChart = null;
    let overallSpeedupChart = null;
    let tableSort = { column: 'worker', direction: 'asc' };
    let sortingInitialized = false;

    // Chart.js defaults
    Chart.defaults.color = '#666666';
    Chart.defaults.borderColor = '#e0e0e0';

    // Check and register boxplot/violin controllers
    console.log('=== Checking for boxplot library ===');
    console.log('window.ChartBoxPlot:', typeof window.ChartBoxPlot);
    console.log('ChartBoxPlot contents:', window.ChartBoxPlot);

    // Register individual controllers from the library
    if (typeof window.ChartBoxPlot !== 'undefined') {
      console.log('Found ChartBoxPlot, registering controllers...');
      const lib = window.ChartBoxPlot;

      // Register each controller individually
      if (lib.BoxPlotController) {
        Chart.register(lib.BoxPlotController);
        console.log('Registered BoxPlotController');
      }
      if (lib.ViolinController) {
        Chart.register(lib.ViolinController);
        console.log('Registered ViolinController');
      }

      // Also try registering as an array
      const controllers = [
        lib.BoxPlotController,
        lib.ViolinController,
        lib.BoxAndWiskers
      ].filter(Boolean);

      if (controllers.length > 0) {
        Chart.register(...controllers);
        console.log('Registered controllers:', controllers.map(c => c.id || c.name));
      }
    }

    console.log('Registered chart types:', Chart.registry.controllers.items);

    function populateBenchmarkOptions() {
      const select = document.getElementById('benchmarkFilter');
      select.innerHTML = '';
      data.benchmarks.forEach((bench, idx) => {
        const option = document.createElement('option');
        option.value = bench.name;
        option.textContent = bench.name;
        if (idx === 0) {
          option.selected = true;
        }
        select.appendChild(option);
      });
    }

    function compareValues(a, b, column) {
      if (column === 'worker') {
        const convert = value => {
          if (value === '—' || value === '' || value === null || value === undefined) {
            return Number.POSITIVE_INFINITY;
          }
          const numeric = Number(value);
          return Number.isNaN(numeric) ? Number.POSITIVE_INFINITY : numeric;
        };
        const na = convert(a[column]);
        const nb = convert(b[column]);
        if (na < nb) return -1;
        if (na > nb) return 1;
        return 0;
      }

      const va = a[column];
      const vb = b[column];
      const na = typeof va === 'number' ? va : parseFloat(va);
      const nb = typeof vb === 'number' ? vb : parseFloat(vb);
      const bothNumbers = !Number.isNaN(na) && !Number.isNaN(nb);
      if (bothNumbers) {
        if (na < nb) return -1;
        if (na > nb) return 1;
        return 0;
      }
      const sa = String(va).toLowerCase();
      const sb = String(vb).toLowerCase();
      if (sa < sb) return -1;
      if (sa > sb) return 1;
      return 0;
    }

    function updateSortIndicators() {
      document.querySelectorAll('#detailsTable thead th[data-column]').forEach(th => {
        if (th.dataset.column === tableSort.column) {
          th.setAttribute('data-sort', tableSort.direction);
        } else {
          th.setAttribute('data-sort', 'none');
        }
      });
    }

    function setupTableSorting() {
      if (sortingInitialized) {
        return;
      }
      document.querySelectorAll('#detailsTable thead th[data-column]').forEach(th => {
        th.setAttribute('data-sort', 'none');
        th.addEventListener('click', () => {
          const column = th.dataset.column;
          if (tableSort.column === column) {
            tableSort.direction = tableSort.direction === 'asc' ? 'desc' : 'asc';
          } else {
            tableSort.column = column;
            tableSort.direction = 'asc';
          }
          updateTable(getSelectedBenchmark());
        });
      });
      sortingInitialized = true;
    }

    function handleBenchmarkChange() {
      tableSort = { column: 'worker', direction: 'asc' };
      updateVisualization();
    }

    function handleControlsChange() {
      updateVisualization();
    }

    function getSelectedBenchmark() {
      const select = document.getElementById('benchmarkFilter');
      const selectedName = select.value || (data.benchmarks[0] && data.benchmarks[0].name);
      return data.benchmarks.find(bench => bench.name === selectedName) || data.benchmarks[0] || null;
    }

    function flattenVariantsForBench(bench) {
      if (!bench) {
        return [];
      }
      return bench.variants.map(variant => ({
        benchmark: bench.name,
        variant: variant.variant,
        worker: variant.worker ?? '—',
        count: variant.count,
        real_mean: variant.real_mean,
        real_stddev: variant.real_stddev,
        real_min: variant.real_min,
        real_max: variant.real_max,
        cpu_mean: variant.cpu_mean,
        gc_mean: variant.gc_mean
      }));
    }

    function updateStats(bench) {
      const statsGrid = document.getElementById('statsGrid');
      if (!bench) {
        statsGrid.innerHTML = '';
        return;
      }

      const variants = bench.variants;
      const totalVariants = variants.length;
      const totalRuns = variants.reduce((acc, variant) => acc + variant.count, 0);
      const avgRealTime = variants.length
        ? (variants.reduce((acc, variant) => acc + variant.real_mean, 0) / variants.length).toFixed(2)
        : 0;

      const sequential = variants.find(v => v.variant === 'sequential');
      const parallelVariants = variants.filter(v => v.variant === 'parallel');
      const maxSpeedup = sequential && parallelVariants.length > 0
        ? Math.max(...parallelVariants.map(p => sequential.real_mean / p.real_mean)).toFixed(2)
        : 'N/A';

      statsGrid.innerHTML = `
        <div class="stat-card">
          <h3>Benchmark</h3>
          <div class="value">${bench.name}</div>
        </div>
        <div class="stat-card">
          <h3>Variants</h3>
          <div class="value">${totalVariants}</div>
        </div>
        <div class="stat-card">
          <h3>Total Runs</h3>
          <div class="value">${totalRuns}</div>
        </div>
        <div class="stat-card">
          <h3>Avg Time</h3>
          <div class="value">${avgRealTime}<span class="unit">ms</span></div>
        </div>
        <div class="stat-card">
          <h3>Max Speedup</h3>
          <div class="value">${maxSpeedup}${maxSpeedup !== 'N/A' ? '<span class="unit">×</span>' : ''}</div>
        </div>
      `;
    }

    function updateTable(bench) {
      const tbody = document.querySelector('#detailsTable tbody');
      tbody.innerHTML = '';

      const rows = flattenVariantsForBench(bench);
      const column = tableSort.column;
      const directionMultiplier = tableSort.direction === 'asc' ? 1 : -1;
      rows.sort((a, b) => directionMultiplier * compareValues(a, b, column));

      rows.forEach(entry => {
        const row = tbody.insertRow();
        row.innerHTML = `
          <td class="benchmark-name">${entry.benchmark}</td>
          <td><span class="variant-name">${entry.variant}</span></td>
          <td class="metric-value">${entry.worker}</td>
          <td class="metric-value">${entry.count}</td>
          <td class="metric-value">${entry.real_mean.toFixed(2)}</td>
          <td class="metric-value">${entry.real_stddev.toFixed(2)}</td>
          <td class="metric-value">${entry.real_min.toFixed(2)}</td>
          <td class="metric-value">${entry.real_max.toFixed(2)}</td>
          <td class="metric-value">${entry.cpu_mean.toFixed(2)}</td>
          <td class="metric-value">${entry.gc_mean.toFixed(2)}</td>
        `;
      });
      updateSortIndicators();
    }

    function updateCharts(bench) {
      const metricType = document.getElementById('metricType').value;
      const scaleType = document.getElementById('scaleToggle').checked ? 'logarithmic' : 'linear';

      if (!bench) {
        if (timingChart) {
          timingChart.destroy();
          timingChart = null;
        }
        if (speedupChart) {
          speedupChart.destroy();
          speedupChart = null;
        }
        return;
      }

      const workerValues = Array.from(new Set(
        bench.variants
          .map(v => v.worker)
          .filter(w => w !== null && w !== undefined && w !== false)
      ));
      workerValues.sort((a, b) => (
        typeof a === 'number' && typeof b === 'number'
          ? a - b
          : String(a).localeCompare(String(b))
      ));

      const labels = workerValues.map(w => `${w}`);
      const variants = Array.from(new Set(bench.variants.map(v => v.variant)));
      const colors = [
        '#4a90e2',
        '#50c878',
        '#f5a623',
        '#bd10e0',
        '#e25555',
        '#7ed321'
      ];

      const timingDatasets = [];

      // Handle sequential variant as a horizontal dashed line
      const sequentialVariant = bench.variants.find(v => v.variant === 'sequential');
      if (sequentialVariant) {
        const sequentialValue = sequentialVariant[metricType];
        const sequentialData = workerValues.map(() => sequentialValue);
        timingDatasets.push({
          label: 'sequential',
          data: sequentialData,
          backgroundColor: 'transparent',
          borderColor: '#888888',
          borderWidth: 2,
          borderDash: [5, 5],
          tension: 0,
          spanGaps: false,
          pointRadius: 0,
          pointHoverRadius: 4
        });
      }

      // Add other variants as regular lines
      variants
        .filter(v => v !== 'sequential')
        .forEach((variant, idx) => {
          const color = colors[idx % colors.length];
          const dataPoints = workerValues.map(worker => {
            const entry = bench.variants.find(v => v.variant === variant && v.worker === worker);
            return entry ? entry[metricType] : null;
          });
          timingDatasets.push({
            label: variant,
            data: dataPoints,
            backgroundColor: color + '20',
            borderColor: color,
            borderWidth: 2,
            tension: 0.2,
            spanGaps: true,
            pointRadius: 4,
            pointHoverRadius: 6
          });
        });

      if (timingChart) {
        timingChart.destroy();
      }

      const timingCtx = document.getElementById('benchmarkChart').getContext('2d');
      timingChart = new Chart(timingCtx, {
        type: 'line',
        data: {
          labels,
          datasets: timingDatasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top'
            },
            title: {
              display: false
            }
          },
          scales: {
            y: {
              type: scaleType,
              beginAtZero: true,
              title: {
                display: true,
                text: 'Time (ms)'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Workers'
              }
            }
          }
        }
      });

      const sequentialByWorker = {};
      bench.variants
        .filter(v => v.variant === 'sequential' && v.worker !== null && v.worker !== undefined)
        .forEach(v => {
          sequentialByWorker[String(v.worker)] = v.real_mean;
        });

      const baseSequential = sequentialByWorker[String(workerValues[0])] ??
        (bench.variants.find(v => v.variant === 'sequential')?.real_mean ?? null);

      const speedupData = workerValues.map(worker => {
        const key = String(worker);
        const sequentialMean = sequentialByWorker[key] ?? baseSequential;
        const parallelEntry = bench.variants.find(v => v.variant === 'parallel' && v.worker === worker);
        if (!parallelEntry || !sequentialMean || parallelEntry.real_mean === 0) {
          return null;
        }
        return sequentialMean / parallelEntry.real_mean;
      });

      const idealSpeedup = workerValues.map(w => w);

      if (speedupChart) {
        speedupChart.destroy();
      }

      const speedupCtx = document.getElementById('speedupChart').getContext('2d');
      speedupChart = new Chart(speedupCtx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            {
              label: 'Observed',
              data: speedupData,
              backgroundColor: '#4a90e220',
              borderColor: '#4a90e2',
              borderWidth: 2,
              tension: 0.2,
              spanGaps: true,
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: 'Ideal Linear',
              data: idealSpeedup,
              backgroundColor: 'transparent',
              borderColor: '#cccccc',
              borderWidth: 1,
              borderDash: [5, 5],
              tension: 0,
              pointRadius: 0
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top'
            },
            title: {
              display: false
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Speedup (×)'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Workers'
              }
            }
          }
        }
      });
    }

    function createOverallSpeedupChart() {
      console.log('=== createOverallSpeedupChart called ===');
      console.log('data.benchmarks:', data.benchmarks);

      // Sort benchmarks to group v1 and v2 versions together
      const sortedBenchmarks = [...data.benchmarks].sort((a, b) => {
        const aBase = a.name.replace(/-v2$/, '');
        const bBase = b.name.replace(/-v2$/, '');
        if (aBase !== bBase) {
          return aBase.localeCompare(bBase);
        }
        // v1 comes before v2
        return a.name.localeCompare(b.name);
      });
      console.log('sortedBenchmarks:', sortedBenchmarks.map(b => b.name));

      // Collect all worker counts
      const allWorkerCounts = new Set();
      sortedBenchmarks.forEach(bench => {
        bench.variants.forEach(v => {
          if (v.worker !== null && v.worker !== undefined && v.worker !== false) {
            allWorkerCounts.add(v.worker);
          }
        });
      });
      const workerValues = Array.from(allWorkerCounts).sort((a, b) => a - b);
      console.log('workerValues:', workerValues);

      // Define colors for different worker counts
      const workerColors = {
        1: '#808080',  // gray
        2: '#4a90e2',  // blue
        4: '#2ecc71',  // green
        6: '#f39c12',  // orange
        8: '#e74c3c',  // red
        12: '#9b59b6', // purple
        16: '#1abc9c', // turquoise
      };

      // Create datasets - one per worker count
      const datasets = [];

      workerValues.forEach(workers => {
        console.log(`\nProcessing worker count: ${workers}`);
        const color = workerColors[workers] || '#95a5a6';
        const dataPoints = [];

        sortedBenchmarks.forEach((bench, benchIdx) => {
          // Find sequential baseline
          // For -v2 benchmarks, use the original benchmark's sequential time for comparison
          let sequentialTime;
          if (bench.name.endsWith('-v2')) {
            const baseName = bench.name.replace(/-v2$/, '');
            const originalBench = sortedBenchmarks.find(b => b.name === baseName);
            if (originalBench) {
              const sequentialVariant = originalBench.variants.find(v => v.variant === 'sequential');
              if (sequentialVariant) {
                sequentialTime = sequentialVariant.real_mean;
                console.log(`  ${bench.name}: Using ${baseName} sequential baseline (${sequentialTime.toFixed(2)}ms)`);
              }
            }
          }

          // If not found above (not v2, or v2 but no original), use own sequential
          if (!sequentialTime) {
            const sequentialVariant = bench.variants.find(v => v.variant === 'sequential');
            if (!sequentialVariant) {
              console.log(`  ${bench.name}: No sequential variant found`);
              return;
            }
            sequentialTime = sequentialVariant.real_mean;
          }

          // Find parallel entry for this worker count
          const parallelEntry = bench.variants.find(v =>
            v.variant === 'parallel' && v.worker === workers
          );

          if (!parallelEntry) {
            console.log(`  ${bench.name}: No parallel entry for ${workers} workers`);
            return;
          }

          if (!parallelEntry.real_values) {
            console.log(`  ${bench.name}: No real_values for ${workers} workers`);
            return;
          }

          if (parallelEntry && parallelEntry.real_mean > 0 && parallelEntry.real_values) {
            // Calculate speedup for each raw timing value
            const speedupValues = parallelEntry.real_values.map(time => sequentialTime / time);

            // Calculate statistics from speedup values
            const speedupMean = sequentialTime / parallelEntry.real_mean;
            const speedupMin = Math.min(...speedupValues);
            const speedupMax = Math.max(...speedupValues);

            console.log(`  ${bench.name}: speedupValues=${JSON.stringify(speedupValues)}, mean=${speedupMean.toFixed(2)}`);

            // For violin plots with category scale, just push the array of values
            // The labels are defined at the chart level, so this matches by index
            dataPoints.push(speedupValues);
          }
        });

        console.log(`  Total dataPoints for ${workers} workers: ${dataPoints.length}`);

        datasets.push({
          label: `${workers} worker${workers > 1 ? 's' : ''}`,
          data: dataPoints,
          backgroundColor: color + '40',
          borderColor: color,
          borderWidth: 2,
          outlierColor: color,
          itemRadius: 0,
          meanRadius: 0
        });
      });

      if (overallSpeedupChart) {
        overallSpeedupChart.destroy();
      }

      // For vertical violin plots, we'll rely on y-axis grid lines instead of custom annotations
      const lineAnnotations = {};

      console.log('\nFinal datasets:', datasets);
      console.log('Total datasets:', datasets.length);
      console.log('First dataset sample:', {
        label: datasets[0].label,
        dataLength: datasets[0].data.length,
        firstDataPoint: datasets[0].data[0],
        secondDataPoint: datasets[0].data[1]
      });
      console.log('lineAnnotations:', lineAnnotations);

      const labelArray = sortedBenchmarks.map(b => b.name);
      console.log('Labels array:', labelArray);
      console.log('Labels count:', labelArray.length);

      const ctx = document.getElementById('overallSpeedupChart').getContext('2d');
      console.log('Canvas context:', ctx);

      const chartData = {
        labels: labelArray,
        datasets
      };
      console.log('Chart data structure:', {
        labelsCount: chartData.labels.length,
        datasetsCount: chartData.datasets.length
      });

      try {
        overallSpeedupChart = new Chart(ctx, {
          type: 'violin',
          data: chartData,
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            layout: {
              padding: {
                left: 40,
                right: 40,
                top: 10,
                bottom: 10
              }
            },
            datasets: {
              violin: {
                barPercentage: 0.33,
                categoryPercentage: 0.8
              }
            },
          interaction: {
            mode: 'nearest',
            intersect: true,
          },
          plugins: {
            annotation: {
              annotations: lineAnnotations
            },
            legend: {
              display: true,
              position: 'right',
              labels: {
                usePointStyle: true,
                padding: 12,
                font: {
                  size: 11
                }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const benchName = context.chart.data.labels[context.dataIndex];
                  const dataPoint = context.raw;

                  // dataPoint is an array of values for violin plots
                  if (Array.isArray(dataPoint)) {
                    const values = dataPoint;
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    const median = values.sort((a, b) => a - b)[Math.floor(values.length / 2)];
                    const mean = values.reduce((a, b) => a + b, 0) / values.length;

                    return [
                      `${benchName} - ${context.dataset.label}`,
                      `Mean: ${mean.toFixed(2)}×`,
                      `Median: ${median.toFixed(2)}×`,
                      `Range: ${min.toFixed(2)}× - ${max.toFixed(2)}×`
                    ];
                  }
                  return `${benchName} - ${context.dataset.label}`;
                }
              }
            }
          },
          scales: {
            x: {
              type: 'linear',
              beginAtZero: true,
              title: {
                display: true,
                text: 'Speedup',
                font: {
                  size: 14,
                  weight: 'bold'
                }
              },
              ticks: {
                callback: function(value) {
                  return value.toFixed(1) + '×';
                }
              },
              grid: {
                color: '#e0e0e0'
              }
            },
            y: {
              type: 'category',
              offset: true,
              stacked: true,
              title: {
                display: true,
                text: 'Benchmark',
                font: {
                  size: 14,
                  weight: 'bold'
                }
              },
              grid: {
                display: false
              }
            }
          }
        }
      });
      console.log('Chart created successfully!', overallSpeedupChart);

      // Log internal chart state
      console.log('Chart config:', {
        type: overallSpeedupChart.config.type,
        dataLabels: overallSpeedupChart.data.labels,
        datasetsCount: overallSpeedupChart.data.datasets.length
      });

      // Log the parsed datasets
      console.log('Chart datasets after initialization:');
      overallSpeedupChart.data.datasets.forEach((ds, idx) => {
        console.log(`  Dataset ${idx} (${ds.label}):`, {
          dataLength: ds.data.length,
          firstPoint: ds.data[0],
          type: ds.type
        });
      });

      // Check if chart has scales
      console.log('Chart scales:', Object.keys(overallSpeedupChart.scales || {}));
      if (overallSpeedupChart.scales) {
        Object.keys(overallSpeedupChart.scales).forEach(scaleId => {
          const scale = overallSpeedupChart.scales[scaleId];
          console.log(`  Scale ${scaleId}:`, {
            type: scale.type,
            min: scale.min,
            max: scale.max,
            ticks: scale.ticks?.length
          });
        });
      }

      // Force update
      console.log('Forcing chart update...');
      overallSpeedupChart.update();
      console.log('Chart update complete');

    } catch (error) {
      console.error('Error creating chart:', error);
      console.error('Error stack:', error.stack);
    }
  }

    function updateVisualization() {
      const bench = getSelectedBenchmark();
      updateStats(bench);
      updateTable(bench);
      updateCharts(bench);
    }

    document.getElementById('timestamp').textContent = new Date().toLocaleString();
    let dataPoints = 0;
    data.benchmarks.forEach(bench => {
      bench.variants.forEach(variant => {
        dataPoints += variant.count;
      });
    });
    document.getElementById('dataPoints').textContent = dataPoints;

    populateBenchmarkOptions();
    setupTableSorting();
    createOverallSpeedupChart();
    document.getElementById('benchmarkFilter').addEventListener('change', handleBenchmarkChange);
    document.getElementById('metricType').addEventListener('change', handleControlsChange);
    document.getElementById('scaleToggle').addEventListener('change', handleControlsChange);
    updateVisualization();
  </script>
</body>
</html>
