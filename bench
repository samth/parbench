#!/usr/bin/env racket
#lang racket

;; bench - Unified benchmark runner for parbench
;;
;; Usage:
;;   ./bench [SUITE|BENCHMARK...] [OPTIONS]
;;
;; Suites:
;;   all         Run all benchmarks (default)
;;   mpl         MPL parallel benchmarks (27)
;;   shootout    Shootout benchmarks (12)
;;   racket      Racket benchmarks (3)
;;
;; Individual benchmarks can also be specified by name (e.g., fib, bmbench)
;;
;; Options:
;;   --quick, -q         Quick smoke test mode (3 iterations, limited cores)
;;   --quiet             Suppress per-benchmark output
;;   --iterations, -i N  Number of iterations per benchmark (default: 10)
;;   --cores, -c N,M,... Specific worker counts (comma-separated)
;;   --cores, -c N-M     Range of worker counts (e.g., 1-8)
;;   --output, -o DIR    Output base directory (default: ./results)
;;   --update, -u DIR    Update existing run directory (don't create new timestamp)
;;   --no-html           Skip HTML report generation
;;   --list, -l          List available benchmarks
;;   --dry-run, -n       Show commands without executing
;;   --help, -h          Show this help
;;
;; Examples:
;;   ./bench                     # Run all benchmarks with auto core sweep
;;   ./bench mpl                 # Just MPL benchmarks
;;   ./bench fib nqueens         # Just fib and nqueens benchmarks
;;   ./bench --quick             # Quick smoke test
;;   ./bench --iterations 5      # Run with 5 iterations each
;;   ./bench --cores 1,4,8       # Specific core counts
;;   ./bench mpl --cores 1-4     # MPL with cores 1,2,4
;;   ./bench --update results/20260109-160016  # Update existing run

(require racket/cmdline
         racket/file
         racket/path
         racket/system
         racket/list
         racket/string
         racket/date
         json
         "benchmarks/tools/analysis.rkt")

;; ============================================================================
;; Benchmark Configurations
;; ============================================================================

;; MPL benchmarks: (name args...)
(define mpl-benchmarks
  '((histogram "--n" "200000000")
    (integer-sort "--n" "50000000" "--range" "10000")
    (bfs "--n" "8000000" "--graph-type" "grid")
    (convex-hull "--n" "2500000")
    (mis "--n" "1500000")
    (msf "--n" "120000")
    (suffix-array "--n" "600000")
    (primes "--n" "50000000")
    (merge-sort "--n" "5000000")
    (samplesort "--n" "2000000")
    (tokens "--size" "5000000")
    (nqueens "--n" "13")
    (dedup "--n" "5000000" "--unique" "500000")
    (word-count "--size" "40000000")
    (fib "--n" "42" "--threshold" "30")
    (shuffle "--n" "5000000" "--chunk-size" "500000")
    (grep "--lines" "2000000")
    (palindrome "--n" "500000000")
    (parens "--n" "150000000")
    (mcss "--n" "100000000")
    (flatten "--n" "600000" "--avg-size" "100")
    (collect "--n" "15000000")
    (bignum-add "--n" "50000000" "--chunk-size" "5000000")
    (subset-sum "--n" "28" "--goal" "10000" "--max-value" "100")
    (triangle-count "--n" "17000" "--edges" "1000000")
    (connectivity "--n" "2000000" "--edges" "8000000")
    (centrality "--n" "20000" "--edges" "100000")))

;; Shootout benchmarks: (name args...)
(define shootout-benchmarks
  '((binary-trees "--n" "18")
    (binary-trees-v2 "--n" "18")
    (spectral-norm "--n" "3000")
    (spectral-norm-v2 "--n" "3000")
    (fannkuch-redux "--n" "11")
    (fannkuch-redux-v2 "--n" "11")
    (mandelbrot "--n" "4000")
    (mandelbrot-v2 "--n" "4000")
    (k-nucleotide "--n" "500000")
    (k-nucleotide-v2 "--n" "500000")
    (regex-dna "--n" "500000")
    (regex-dna-v2 "--n" "500000")))

;; Racket benchmarks: (name args...)
(define racket-benchmarks
  '((bmbench "--n" "1000000")
    (richards "--iterations" "100")
    (rows1b "--rows" "2000000" "--chunk-size" "200000")))

;; All benchmark names by suite
(define mpl-names (map first mpl-benchmarks))
(define shootout-names (map first shootout-benchmarks))
(define racket-names (map first racket-benchmarks))

;; ============================================================================
;; Parameters
;; ============================================================================

(define quick-mode (make-parameter #f))
(define quiet-mode (make-parameter #f))
(define dry-run-mode (make-parameter #f))
(define generate-html (make-parameter #t))
(define iterations (make-parameter 10))

;; ============================================================================
;; Core Detection
;; ============================================================================

(define (detect-cores)
  (with-handlers ([exn:fail? (λ (_) 8)])
    (cond
      [(find-executable-path "nproc")
       (string->number (string-trim (with-output-to-string
                                      (λ () (system "nproc")))))]
      [(find-executable-path "sysctl")
       (string->number (string-trim (with-output-to-string
                                      (λ () (system "sysctl -n hw.ncpu")))))]
      [else 8])))

(define (default-worker-counts)
  (define max-cores (detect-cores))
  (filter (λ (n) (<= n max-cores))
          '(1 2 4 6 8 12 16 24 32)))

;; Parse worker counts from string
;; Supports: "1,2,4,8" or "1-8" (range with common values)
(define (parse-worker-counts str)
  (cond
    [(regexp-match #rx"^([0-9]+)-([0-9]+)$" str)
     => (λ (m)
          (define start (string->number (second m)))
          (define end (string->number (third m)))
          (filter (λ (n) (and (>= n start) (<= n end)))
                  '(1 2 4 6 8 12 16 24 32)))]
    [(equal? str "max")
     (list (detect-cores))]
    [else
     (map string->number (string-split str ","))]))

;; ============================================================================
;; Benchmark Discovery
;; ============================================================================

;; Returns suite name ('mpl, 'shootout, 'racket) or #f
(define (get-benchmark-suite name)
  (define name-sym (if (symbol? name) name (string->symbol name)))
  (cond
    [(member name-sym mpl-names) 'mpl]
    [(member name-sym shootout-names) 'shootout]
    [(member name-sym racket-names) 'racket]
    [else #f]))

;; Get benchmark config from suite
(define (get-benchmark-config name)
  (define name-sym (if (symbol? name) name (string->symbol name)))
  (or (findf (λ (c) (eq? (first c) name-sym)) mpl-benchmarks)
      (findf (λ (c) (eq? (first c) name-sym)) shootout-benchmarks)
      (findf (λ (c) (eq? (first c) name-sym)) racket-benchmarks)))

;; Get benchmark directory
(define (suite->directory suite)
  (case suite
    [(mpl) "mpl"]
    [(shootout) "shootout"]
    [(racket) "racket"]
    [else (error 'suite->directory "unknown suite: ~a" suite)]))

;; ============================================================================
;; Listing
;; ============================================================================

(define (list-benchmarks)
  (printf "~nAvailable benchmarks:~n~n")
  (printf "MPL (~a):~n" (length mpl-names))
  (printf "  ~a~n~n" (string-join (map symbol->string mpl-names) ", "))
  (printf "Shootout (~a):~n" (length shootout-names))
  (printf "  ~a~n~n" (string-join (map symbol->string shootout-names) ", "))
  (printf "Racket (~a):~n" (length racket-names))
  (printf "  ~a~n~n" (string-join (map symbol->string racket-names) ", "))
  (exit 0))

;; ============================================================================
;; Benchmark Running
;; ============================================================================

(define (run-benchmark name suite log-dir workers)
  (define suite-dir (suite->directory suite))
  (define benchmark-path (build-path "benchmarks" suite-dir (format "~a.rkt" name)))
  (define log-path (build-path log-dir (format "~a.sexp" name)))
  (define config (get-benchmark-config name))
  (define base-args (if config (cdr config) '()))
  ;; Add --repeat with iterations count
  (define args (append base-args (list "--repeat" (number->string (iterations)))))

  (unless (file-exists? benchmark-path)
    (error 'run-benchmark "Benchmark file not found: ~a" benchmark-path))

  ;; Delete existing log if present
  (when (file-exists? log-path)
    (delete-file log-path))

  (when (or (quick-mode) (quiet-mode))
    (printf "  ~a~n" name)
    (flush-output))

  ;; Run sequential (workers=1) first
  (define seq-cmd-args
    (append args (list "--workers" "1" "--log" (path->string log-path))))
  (when (dry-run-mode)
    (printf "    Would run: racket ~a ~a~n" benchmark-path (string-join seq-cmd-args " ")))
  (unless (dry-run-mode)
    (define result
      (if (or (quick-mode) (quiet-mode))
          (parameterize ([current-output-port (open-output-nowhere)]
                         [current-error-port (open-output-nowhere)])
            (apply system* (find-executable-path "racket")
                   (path->string benchmark-path) seq-cmd-args))
          (begin
            (printf "  Running ~a...~n" name)
            (apply system* (find-executable-path "racket")
                   (path->string benchmark-path) seq-cmd-args))))
    (unless result
      (eprintf "    Warning: ~a sequential failed~n" name)))

  ;; Run parallel for each worker count (skip workers=1, already run as sequential)
  (for ([w workers]
        #:when (> w 1))
    (define par-cmd-args
      (append args (list "--workers" (number->string w)
                         "--log" (path->string log-path)
                         "--skip-sequential")))
    (when (dry-run-mode)
      (printf "    Would run: racket ~a ~a~n" benchmark-path (string-join par-cmd-args " ")))
    (unless (dry-run-mode)
      (define result
        (if (or (quick-mode) (quiet-mode))
            (parameterize ([current-output-port (open-output-nowhere)]
                           [current-error-port (open-output-nowhere)])
              (apply system* (find-executable-path "racket")
                     (path->string benchmark-path) par-cmd-args))
            (apply system* (find-executable-path "racket")
                   (path->string benchmark-path) par-cmd-args)))
      (unless result
        (eprintf "    Warning: ~a with ~a workers failed~n" name w)))))

(define (run-suite suite log-dir workers)
  (printf "Running ~a benchmarks...~n" suite)
  (unless (or (quick-mode) (quiet-mode))
    (printf "  Worker counts: ~a~n" workers)
    (printf "  Log directory: ~a~n~n" log-dir))

  (make-directory* log-dir)

  (define configs
    (case suite
      [(mpl) mpl-benchmarks]
      [(shootout) shootout-benchmarks]
      [(racket) racket-benchmarks]
      [else (error 'run-suite "unknown suite: ~a" suite)]))

  (define total (length configs))
  (for ([config configs]
        [i (in-naturals 1)])
    (define name (first config))
    (when (or (quick-mode) (quiet-mode))
      (printf "  [~a/~a] " i total))
    (run-benchmark name suite log-dir workers)))

;; ============================================================================
;; HTML Report Generation
;; ============================================================================

(define (generate-combined-report output-dir html-file title suite-dirs)
  (unless (or (quick-mode) (quiet-mode))
    (printf "Generating combined HTML report...~n"))

  ;; Collect all .sexp files from specified suite directories
  (define log-files
    (apply append
           (for/list ([dir suite-dirs]
                      #:when (directory-exists? dir))
             (for/list ([f (directory-list dir #:build? #t)]
                        #:when (equal? (path-get-extension f) #".sexp"))
               f))))

  (cond
    [(null? log-files)
     (printf "  No log files found to combine~n")]

    [(dry-run-mode)
     (unless (or (quick-mode) (quiet-mode))
       (printf "  Found ~a log file(s)~n" (length log-files)))
     (printf "Would generate HTML report: ~a~n" html-file)]

    [else
     (unless (or (quick-mode) (quiet-mode))
       (printf "  Found ~a log file(s)~n" (length log-files)))

     ;; Load data
     (define file-paths (map path->string log-files))
     (define summaries (load-summaries file-paths))
     (define raw-data-list (load-raw-data file-paths))

     ;; Build lookup for raw values
     (define raw-lookup
       (for/hash ([rd raw-data-list])
         (values (list (raw-data-name rd) (raw-data-variant rd) (raw-data-worker rd))
                 (raw-data-real-values rd))))

     ;; Generate JSON
     (define json-data
       (jsexpr->string
        (hasheq
         'benchmarks
         (for/list ([bench-summaries (group-by summary-name summaries)])
           (define bench-name (summary-name (first bench-summaries)))
           (hasheq
            'name (symbol->string bench-name)
            'variants
            (for/list ([s bench-summaries])
              (define key (list (summary-name s) (summary-variant s) (summary-worker s)))
              (define raw-values (hash-ref raw-lookup key '()))
              (hasheq
               'variant (symbol->string (summary-variant s))
               'worker (summary-worker s)
               'count (summary-count s)
               'real_mean (summary-real-mean s)
               'real_stddev (summary-real-stddev s)
               'real_min (summary-real-min s)
               'real_max (summary-real-max s)
               'cpu_mean (summary-cpu-mean s)
               'gc_mean (summary-gc-mean s)
               'real_values raw-values)))))))

     ;; Read template
     (define template-path
       (build-path "benchmarks" "tools" "templates" "visualization.html"))
     (define template (file->string template-path))

     ;; Generate HTML
     (define html
       (string-replace
        (string-replace template "@@TITLE@@" title #:all? #t)
        "@@DATA@@" json-data #:all? #t))

     ;; Write output
     (call-with-output-file html-file
       #:exists 'replace
       (λ (out) (write-string html out)))

     (unless (or (quick-mode) (quiet-mode))
       (printf "  Visualization saved to: ~a~n" html-file))]))

;; ============================================================================
;; Main
;; ============================================================================

(module+ main
  ;; Configuration
  (define output-base "results")
  (define update-dir #f)
  (define worker-counts-str #f)
  (define requested (make-parameter '()))

  (define iterations-str #f)

  ;; Parse command line
  (define args
    (command-line
     #:program "bench"
     #:once-each
     [("--quick" "-q") "Quick smoke test mode (fewer iterations, limited cores)"
      (quick-mode #t)]
     [("--quiet") "Suppress per-benchmark output"
      (quiet-mode #t)]
     [("--iterations" "-i") n "Number of iterations per benchmark (default: 10)"
      (set! iterations-str n)]
     [("--cores" "-c") counts "Worker counts (comma-separated or range)"
      (set! worker-counts-str counts)]
     [("--output" "-o") dir "Output base directory"
      (set! output-base dir)]
     [("--update" "-u") dir "Update existing run directory"
      (set! update-dir dir)]
     [("--no-html") "Skip HTML report generation"
      (generate-html #f)]
     [("--list" "-l") "List available benchmarks"
      (list-benchmarks)]
     [("--dry-run" "-n") "Show commands without executing"
      (dry-run-mode #t)]
     #:args benchmarks
     benchmarks))

  ;; Set iterations (quick mode uses 3 by default)
  (cond
    [iterations-str (iterations (string->number iterations-str))]
    [(quick-mode) (iterations 3)])

  ;; Parse worker counts
  (define workers
    (cond
      [worker-counts-str (parse-worker-counts worker-counts-str)]
      [(quick-mode) '(1 4)]
      [else (default-worker-counts)]))

  ;; Determine output directory
  (define output-dir
    (cond
      [update-dir
       (unless (directory-exists? update-dir)
         (error 'bench "Update directory does not exist: ~a" update-dir))
       update-dir]
      [else
       (define run-id (date->string (current-date) #t))
       ;; Format: YYYYMMDD-HHMMSS
       (define timestamp
         (format "~a~a~a-~a~a~a"
                 (date-year (current-date))
                 (~r (date-month (current-date)) #:min-width 2 #:pad-string "0")
                 (~r (date-day (current-date)) #:min-width 2 #:pad-string "0")
                 (~r (date-hour (current-date)) #:min-width 2 #:pad-string "0")
                 (~r (date-minute (current-date)) #:min-width 2 #:pad-string "0")
                 (~r (date-second (current-date)) #:min-width 2 #:pad-string "0")))
       (build-path output-base timestamp)]))

  (make-directory* output-dir)

  ;; Default to "all" if nothing specified
  (define items
    (if (null? args) '("all") args))

  ;; Check if running suites or individual benchmarks
  (define suites (filter (λ (x) (member x '("all" "mpl" "shootout" "racket"))) items))
  (define benchmarks (filter (λ (x) (not (member x '("all" "mpl" "shootout" "racket")))) items))

  (when (and (not (null? suites)) (not (null? benchmarks)))
    (error 'bench "Cannot mix suite names (all, mpl, shootout, racket) with individual benchmark names"))

  ;; Print header
  (newline)
  (cond
    [(quick-mode)
     (printf "Parbench (quick mode)~n")]
    [(quiet-mode)
     (printf "Parbench~n")]
    [else
     (printf "========================================~n")
     (printf "  Parbench - Parallel Benchmark Suite~n")
     (printf "========================================~n~n")
     (printf "Benchmarks:    ~a~n" (string-join items " "))
     (printf "Iterations:    ~a~n" (iterations))
     (printf "Worker counts: ~a~n" workers)
     (printf "Output dir:    ~a~n" output-dir)
     (printf "Detected cores: ~a~n" (detect-cores))])
  (newline)

  ;; Track suite directories for HTML report
  (define suite-dirs '())

  (cond
    ;; Running suites
    [(not (null? suites))
     (for ([item suites])
       (case (string->symbol item)
         [(all)
          (run-suite 'mpl (build-path output-dir "mpl") workers)
          (set! suite-dirs (cons (build-path output-dir "mpl") suite-dirs))
          (newline)
          (run-suite 'shootout (build-path output-dir "shootout") workers)
          (set! suite-dirs (cons (build-path output-dir "shootout") suite-dirs))
          (newline)
          (run-suite 'racket (build-path output-dir "racket") workers)
          (set! suite-dirs (cons (build-path output-dir "racket") suite-dirs))]
         [(mpl shootout racket)
          (define suite (string->symbol item))
          (define dir (build-path output-dir item))
          (run-suite suite dir workers)
          (set! suite-dirs (cons dir suite-dirs))]))]

    ;; Running individual benchmarks
    [else
     ;; Group by suite
     (define grouped (make-hash))
     (for ([bench benchmarks])
       (define suite (get-benchmark-suite bench))
       (unless suite
         (error 'bench "Unknown benchmark: ~a~nRun 'racket bench.rkt --list' to see available benchmarks" bench))
       (hash-update! grouped suite (λ (lst) (cons bench lst)) '()))

     (for ([(suite bench-list) (in-hash grouped)])
       (define dir (build-path output-dir (suite->directory suite)))
       (make-directory* dir)
       (printf "Running ~a benchmarks...~n" suite)
       (for ([bench (reverse bench-list)])
         (run-benchmark (string->symbol bench) suite dir workers))
       (set! suite-dirs (cons dir suite-dirs)))])

  ;; Generate HTML report
  (when (generate-html)
    (newline)
    (define title
      (cond
        [(member "all" suites) "All Benchmarks"]
        [(not (null? suites))
         (string-join (map (λ (s) (format "~a Benchmarks" (string-titlecase s))) suites) " + ")]
        [else
         (format "Selected Benchmarks: ~a" (string-join benchmarks ", "))]))
    (generate-combined-report output-dir
                              (build-path output-dir "results.html")
                              title
                              (reverse suite-dirs)))

  ;; Summary
  (newline)
  (cond
    [(or (quick-mode) (quiet-mode))
     (printf "Done. Results: ~a/results.html~n" output-dir)]
    [else
     (printf "========================================~n")
     (printf "  Complete!~n")
     (printf "========================================~n~n")
     (printf "Results saved to: ~a/~n" output-dir)
     (when (generate-html)
       (newline)
       (printf "View results:~n")
       (printf "  open ~a/results.html~n" output-dir))]))
