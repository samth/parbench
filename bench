#!/usr/bin/env racket
#lang racket

;; bench - Unified benchmark runner for parbench
;;
;; Usage:
;;   ./bench [SUITE|BENCHMARK...] [OPTIONS]
;;
;; Suites:
;;   all         Run all benchmarks (default)
;;   mpl         MPL parallel benchmarks (27)
;;   shootout    Shootout benchmarks (12)
;;   racket      Racket benchmarks (3)
;;
;; Individual benchmarks can also be specified by name (e.g., fib, bmbench)
;;
;; Options:
;;   --quick, -q         Quick smoke test mode (3 iterations, limited cores)
;;   --verbose, -v       Show detailed per-benchmark output
;;   --save, -s          Save results to log files
;;   --html              Generate HTML report (implies --save)
;;   --iterations, -i N  Number of iterations per benchmark (default: 10)
;;   --cores, -c N,M,... Specific worker counts (comma-separated)
;;   --cores, -c N-M     Range of worker counts (e.g., 1-8)
;;   --output, -o DIR    Output base directory (default: ./results)
;;   --update, -u DIR    Update existing run directory (implies --save)
;;   --list, -l          List available benchmarks
;;   --dry-run, -n       Show commands without executing
;;   --help, -h          Show this help
;;
;; By default, runs quietly without saving files, printing a summary table.
;;
;; Examples:
;;   ./bench fib                 # Run fib, print summary
;;   ./bench mpl                 # Run all MPL benchmarks
;;   ./bench --quick             # Quick smoke test (3 iterations)
;;   ./bench -v fib              # Verbose output
;;   ./bench --save fib          # Save log files
;;   ./bench --html fib          # Save logs and generate HTML report
;;   ./bench --iterations 5      # Run with 5 iterations each
;;   ./bench --cores 1,4,8       # Specific core counts
;;   ./bench --update results/20260109-160016  # Update existing run

(require racket/cmdline
         racket/file
         racket/path
         racket/system
         racket/list
         racket/string
         racket/date
         json
         "benchmarks/tools/analysis.rkt")

;; ============================================================================
;; Benchmark Configurations
;; ============================================================================

;; MPL benchmarks: (name args...)
(define mpl-benchmarks
  '((histogram "--n" "200000000")
    (integer-sort "--n" "50000000" "--range" "10000")
    (bfs "--n" "8000000" "--graph-type" "grid")
    (convex-hull "--n" "2500000")
    (mis "--n" "1500000")
    (msf "--n" "120000")
    (suffix-array "--n" "600000")
    (primes "--n" "50000000")
    (merge-sort "--n" "5000000")
    (samplesort "--n" "2000000")
    (tokens "--size" "5000000")
    (nqueens "--n" "13")
    (dedup "--n" "5000000" "--unique" "500000")
    (word-count "--size" "40000000")
    (fib "--n" "42" "--threshold" "30")
    (shuffle "--n" "5000000" "--chunk-size" "500000")
    (grep "--lines" "2000000")
    (palindrome "--n" "500000000")
    (parens "--n" "150000000")
    (mcss "--n" "100000000")
    (flatten "--n" "600000" "--avg-size" "100")
    (collect "--n" "15000000")
    (bignum-add "--n" "50000000" "--chunk-size" "5000000")
    (subset-sum "--n" "28" "--goal" "10000" "--max-value" "100")
    (triangle-count "--n" "17000" "--edges" "1000000")
    (connectivity "--n" "2000000" "--edges" "8000000")
    (centrality "--n" "20000" "--edges" "100000")))

;; Shootout benchmarks: (name args...)
;; All have parallel implementations built in
(define shootout-benchmarks
  '((binary-trees "--n" "18")
    (spectral-norm "--n" "3000")
    (fannkuch-redux "--n" "11")
    (mandelbrot "--n" "4000")
    (k-nucleotide "--n" "500000")
    (regex-dna "--n" "500000")))

;; Racket benchmarks: (name args...)
(define racket-benchmarks
  '((bmbench "--n" "1000000")
    (richards "--iterations" "100")
    (rows1b "--rows" "2000000" "--chunk-size" "200000")))

;; All benchmark names by suite
(define mpl-names (map first mpl-benchmarks))
(define shootout-names (map first shootout-benchmarks))
(define racket-names (map first racket-benchmarks))

;; ============================================================================
;; Parameters
;; ============================================================================

(define quick-mode (make-parameter #f))
(define quiet-mode (make-parameter #t))   ; quiet by default
(define dry-run-mode (make-parameter #f))
(define generate-html (make-parameter #f)) ; no HTML by default
(define save-results (make-parameter #f))  ; no save by default
(define iterations (make-parameter 10))

;; Results storage for --no-save mode: hash of (benchmark worker) -> (listof real-ms)
(define collected-results (make-hash))

;; ============================================================================
;; Core Detection
;; ============================================================================

(define (detect-cores)
  (with-handlers ([exn:fail? (λ (_) 8)])
    (cond
      [(find-executable-path "nproc")
       (string->number (string-trim (with-output-to-string
                                      (λ () (system "nproc")))))]
      [(find-executable-path "sysctl")
       (string->number (string-trim (with-output-to-string
                                      (λ () (system "sysctl -n hw.ncpu")))))]
      [else 8])))

(define (default-worker-counts)
  (define max-cores (detect-cores))
  (filter (λ (n) (<= n max-cores))
          '(1 2 4 6 8 12 16 24 32)))

;; Parse worker counts from string
;; Supports: "1,2,4,8" or "1-8" (range with common values)
(define (parse-worker-counts str)
  (cond
    [(regexp-match #rx"^([0-9]+)-([0-9]+)$" str)
     => (λ (m)
          (define start (string->number (second m)))
          (define end (string->number (third m)))
          (filter (λ (n) (and (>= n start) (<= n end)))
                  '(1 2 4 6 8 12 16 24 32)))]
    [(equal? str "max")
     (list (detect-cores))]
    [else
     (map string->number (string-split str ","))]))

;; ============================================================================
;; Benchmark Discovery
;; ============================================================================

;; Returns suite name ('mpl, 'shootout, 'racket) or #f
(define (get-benchmark-suite name)
  (define name-sym (if (symbol? name) name (string->symbol name)))
  (cond
    [(member name-sym mpl-names) 'mpl]
    [(member name-sym shootout-names) 'shootout]
    [(member name-sym racket-names) 'racket]
    [else #f]))

;; Get benchmark config from suite
(define (get-benchmark-config name)
  (define name-sym (if (symbol? name) name (string->symbol name)))
  (or (findf (λ (c) (eq? (first c) name-sym)) mpl-benchmarks)
      (findf (λ (c) (eq? (first c) name-sym)) shootout-benchmarks)
      (findf (λ (c) (eq? (first c) name-sym)) racket-benchmarks)))

;; Get benchmark directory
(define (suite->directory suite)
  (case suite
    [(mpl) "mpl"]
    [(shootout) "shootout"]
    [(racket) "racket"]
    [else (error 'suite->directory "unknown suite: ~a" suite)]))

;; ============================================================================
;; Statistics
;; ============================================================================

(define (mean lst)
  (if (null? lst) 0 (/ (apply + lst) (length lst))))

(define (median lst)
  (if (null? lst)
      0
      (let ([sorted (sort lst <)]
            [n (length lst)])
        (if (odd? n)
            (list-ref sorted (quotient n 2))
            (/ (+ (list-ref sorted (- (quotient n 2) 1))
                  (list-ref sorted (quotient n 2)))
               2)))))

(define (minimum lst)
  (if (null? lst) 0 (apply min lst)))

;; Parse benchmark sexp output and extract real-ms values
(define (parse-benchmark-output output)
  (define results '())
  (with-handlers ([exn:fail? (λ (_) results)])
    (define in (open-input-string output))
    (let loop ()
      (define expr (read in))
      (when (and (list? expr) (eq? (first expr) 'benchmark))
        (define metrics (assoc 'metrics (cdr expr)))
        (when metrics
          (define real-ms (assoc 'real-ms (cdr metrics)))
          (when real-ms
            (set! results (cons (second real-ms) results)))))
      (unless (eof-object? (peek-char in))
        (loop)))
    results))

;; Store results for a benchmark run
(define (store-result! name workers real-ms-list)
  (define key (list name workers))
  (hash-update! collected-results key
                (λ (existing) (append existing real-ms-list))
                '()))

;; ============================================================================
;; Listing
;; ============================================================================

(define (list-benchmarks)
  (printf "~nAvailable benchmarks:~n~n")
  (printf "MPL (~a):~n" (length mpl-names))
  (printf "  ~a~n~n" (string-join (map symbol->string mpl-names) ", "))
  (printf "Shootout (~a):~n" (length shootout-names))
  (printf "  ~a~n~n" (string-join (map symbol->string shootout-names) ", "))
  (printf "Racket (~a):~n" (length racket-names))
  (printf "  ~a~n~n" (string-join (map symbol->string racket-names) ", "))
  (exit 0))

;; ============================================================================
;; Benchmark Running
;; ============================================================================

;; Run a single benchmark invocation, always capturing output for summary
(define (run-benchmark-once benchmark-path cmd-args name workers suppress-output?)
  (cond
    [(dry-run-mode)
     (printf "    Would run: racket ~a ~a~n" benchmark-path (string-join cmd-args " "))
     #t]
    [else
     ;; Always capture stdout for summary table
     (define output-str
       (with-output-to-string
         (λ ()
           (parameterize ([current-error-port (open-output-nowhere)])
             (apply system* (find-executable-path "racket")
                    (path->string benchmark-path) cmd-args)))))
     ;; Parse and store results for summary
     (define real-ms-values (parse-benchmark-output output-str))
     (store-result! name workers real-ms-values)
     ;; Optionally display output
     (unless suppress-output?
       (display output-str))
     (not (null? real-ms-values))]))

(define (run-benchmark name suite log-dir workers)
  (define suite-dir (suite->directory suite))
  (define benchmark-path (build-path "benchmarks" suite-dir (format "~a.rkt" name)))
  (define log-path (build-path log-dir (format "~a.sexp" name)))
  (define config (get-benchmark-config name))
  (define base-args (if config (cdr config) '()))
  ;; Add --repeat with iterations count
  (define args (append base-args (list "--repeat" (number->string (iterations)))))

  (unless (file-exists? benchmark-path)
    (error 'run-benchmark "Benchmark file not found: ~a" benchmark-path))

  ;; Delete existing log if present (only in save mode)
  (when (and (save-results) (file-exists? log-path))
    (delete-file log-path))

  (define suppress-output? (or (quick-mode) (quiet-mode) (not (save-results))))

  (when suppress-output?
    (printf "  ~a~n" name)
    (flush-output))

  ;; Run sequential (workers=1) first - store under 'seq key
  (define seq-cmd-args
    (if (save-results)
        (append args (list "--workers" "1" "--log" (path->string log-path)))
        (append args (list "--workers" "1"))))
  (unless suppress-output?
    (printf "  Running ~a...~n" name))
  (define seq-result (run-benchmark-once benchmark-path seq-cmd-args name 'seq suppress-output?))
  (unless seq-result
    (eprintf "    Warning: ~a sequential failed~n" name))

  ;; Run parallel for each worker count (including 1 if specified)
  (for ([w workers])
    (define par-cmd-args
      (if (save-results)
          (append args (list "--workers" (number->string w)
                             "--log" (path->string log-path)
                             "--skip-sequential"))
          (append args (list "--workers" (number->string w)
                             "--skip-sequential"))))
    (define par-result (run-benchmark-once benchmark-path par-cmd-args name w suppress-output?))
    (unless par-result
      (eprintf "    Warning: ~a with ~a workers failed~n" name w))))

(define (run-suite suite log-dir workers)
  (printf "Running ~a benchmarks...~n" suite)
  (unless (or (quick-mode) (quiet-mode) (not (save-results)))
    (printf "  Worker counts: ~a~n" workers)
    (printf "  Log directory: ~a~n~n" log-dir))

  (when (save-results)
    (make-directory* log-dir))

  (define configs
    (case suite
      [(mpl) mpl-benchmarks]
      [(shootout) shootout-benchmarks]
      [(racket) racket-benchmarks]
      [else (error 'run-suite "unknown suite: ~a" suite)]))

  (define total (length configs))
  (for ([config configs]
        [i (in-naturals 1)])
    (define name (first config))
    (when (or (quick-mode) (quiet-mode))
      (printf "  [~a/~a] " i total))
    (run-benchmark name suite log-dir workers)))

;; ============================================================================
;; HTML Report Generation
;; ============================================================================

(define (generate-combined-report output-dir html-file title suite-dirs)
  (unless (or (quick-mode) (quiet-mode))
    (printf "Generating combined HTML report...~n"))

  ;; Collect all .sexp files from specified suite directories
  (define log-files
    (apply append
           (for/list ([dir suite-dirs]
                      #:when (directory-exists? dir))
             (for/list ([f (directory-list dir #:build? #t)]
                        #:when (equal? (path-get-extension f) #".sexp"))
               f))))

  (cond
    [(null? log-files)
     (printf "  No log files found to combine~n")]

    [(dry-run-mode)
     (unless (or (quick-mode) (quiet-mode))
       (printf "  Found ~a log file(s)~n" (length log-files)))
     (printf "Would generate HTML report: ~a~n" html-file)]

    [else
     (unless (or (quick-mode) (quiet-mode))
       (printf "  Found ~a log file(s)~n" (length log-files)))

     ;; Load data
     (define file-paths (map path->string log-files))
     (define summaries (load-summaries file-paths))
     (define raw-data-list (load-raw-data file-paths))

     ;; Build lookup for raw values
     (define raw-lookup
       (for/hash ([rd raw-data-list])
         (values (list (raw-data-name rd) (raw-data-variant rd) (raw-data-worker rd))
                 (raw-data-real-values rd))))

     ;; Generate JSON
     (define json-data
       (jsexpr->string
        (hasheq
         'benchmarks
         (for/list ([bench-summaries (group-by summary-name summaries)])
           (define bench-name (summary-name (first bench-summaries)))
           (hasheq
            'name (symbol->string bench-name)
            'variants
            (for/list ([s bench-summaries])
              (define key (list (summary-name s) (summary-variant s) (summary-worker s)))
              (define raw-values (hash-ref raw-lookup key '()))
              (hasheq
               'variant (symbol->string (summary-variant s))
               'worker (summary-worker s)
               'count (summary-count s)
               'real_mean (summary-real-mean s)
               'real_stddev (summary-real-stddev s)
               'real_min (summary-real-min s)
               'real_max (summary-real-max s)
               'cpu_mean (summary-cpu-mean s)
               'gc_mean (summary-gc-mean s)
               'real_values raw-values)))))))

     ;; Read template
     (define template-path
       (build-path "benchmarks" "tools" "templates" "visualization.html"))
     (define template (file->string template-path))

     ;; Generate HTML
     (define html
       (string-replace
        (string-replace template "@@TITLE@@" title #:all? #t)
        "@@DATA@@" json-data #:all? #t))

     ;; Write output
     (call-with-output-file html-file
       #:exists 'replace
       (λ (out) (write-string html out)))

     (unless (or (quick-mode) (quiet-mode))
       (printf "  Visualization saved to: ~a~n" html-file))]))

;; ============================================================================
;; Summary Printing (for --no-save mode)
;; ============================================================================

(define (print-results-summary workers)
  (newline)
  (printf "========================================~n")
  (printf "  Results Summary~n")
  (printf "========================================~n~n")

  ;; Group results by benchmark name
  (define benchmarks
    (remove-duplicates
     (for/list ([key (in-hash-keys collected-results)])
       (first key))))

  ;; Columns: 'seq first, then all worker counts from the workers list
  (define all-columns (cons 'seq (sort workers <)))

  ;; Print header
  (printf "~a" (make-string 20 #\space))
  (for ([w all-columns])
    (if (eq? w 'seq)
        (printf "~a" (~a "seq" #:width 24 #:align 'center))
        (printf "~a" (~a (format "~a workers" w) #:width 24 #:align 'center))))
  (newline)
  (printf "~a" (~a "Benchmark" #:width 20))
  (for ([_ all-columns])
    (printf "~a" (~a "mean/median/min" #:width 24 #:align 'center)))
  (newline)
  (printf "~a~n" (make-string (+ 20 (* 24 (length all-columns))) #\-))

  ;; Print each benchmark
  (for ([bench (sort benchmarks symbol<?)])
    (printf "~a" (~a bench #:width 20))
    (for ([w all-columns])
      (define key (list bench w))
      (define results (hash-ref collected-results key '()))
      (if (null? results)
          (printf "~a" (~a "-" #:width 24 #:align 'center))
          (let ([m (mean results)]
                [med (median results)]
                [mn (minimum results)])
            (printf "~a"
                    (~a (format "~a/~a/~a"
                                (exact->inexact (round m))
                                (exact->inexact (round med))
                                mn)
                        #:width 24 #:align 'center)))))
    (newline))

  (newline))

;; ============================================================================
;; Main
;; ============================================================================

(module+ main
  ;; Configuration
  (define output-base "results")
  (define update-dir #f)
  (define worker-counts-str #f)
  (define requested (make-parameter '()))

  (define iterations-str #f)

  ;; Parse command line
  (define args
    (command-line
     #:program "bench"
     #:once-each
     [("--quick" "-q") "Quick smoke test mode (fewer iterations, limited cores)"
      (quick-mode #t)]
     [("--verbose" "-v") "Show detailed per-benchmark output"
      (quiet-mode #f)]
     [("--save" "-s") "Save results to log files"
      (save-results #t)]
     [("--html") "Generate HTML report (implies --save)"
      (save-results #t)
      (generate-html #t)]
     [("--iterations" "-i") n "Number of iterations per benchmark (default: 10)"
      (set! iterations-str n)]
     [("--cores" "-c") counts "Worker counts (comma-separated or range)"
      (set! worker-counts-str counts)]
     [("--output" "-o") dir "Output base directory (default: ./results)"
      (set! output-base dir)]
     [("--update" "-u") dir "Update existing run directory (implies --save)"
      (set! update-dir dir)
      (save-results #t)]
     [("--list" "-l") "List available benchmarks"
      (list-benchmarks)]
     [("--dry-run" "-n") "Show commands without executing"
      (dry-run-mode #t)]
     #:args benchmarks
     benchmarks))

  ;; Set iterations (quick mode uses 3 by default)
  (cond
    [iterations-str (iterations (string->number iterations-str))]
    [(quick-mode) (iterations 3)])

  ;; Parse worker counts
  (define workers
    (cond
      [worker-counts-str (parse-worker-counts worker-counts-str)]
      [(quick-mode) '(1 4)]
      [else (default-worker-counts)]))

  ;; Determine output directory
  (define output-dir
    (cond
      [update-dir
       (unless (directory-exists? update-dir)
         (error 'bench "Update directory does not exist: ~a" update-dir))
       update-dir]
      [else
       (define run-id (date->string (current-date) #t))
       ;; Format: YYYYMMDD-HHMMSS
       (define timestamp
         (format "~a~a~a-~a~a~a"
                 (date-year (current-date))
                 (~r (date-month (current-date)) #:min-width 2 #:pad-string "0")
                 (~r (date-day (current-date)) #:min-width 2 #:pad-string "0")
                 (~r (date-hour (current-date)) #:min-width 2 #:pad-string "0")
                 (~r (date-minute (current-date)) #:min-width 2 #:pad-string "0")
                 (~r (date-second (current-date)) #:min-width 2 #:pad-string "0")))
       (build-path output-base timestamp)]))

  (when (save-results)
    (make-directory* output-dir))

  ;; Default to "all" if nothing specified
  (define items
    (if (null? args) '("all") args))

  ;; Check if running suites or individual benchmarks
  (define suites (filter (λ (x) (member x '("all" "mpl" "shootout" "racket"))) items))
  (define benchmarks (filter (λ (x) (not (member x '("all" "mpl" "shootout" "racket")))) items))

  (when (and (not (null? suites)) (not (null? benchmarks)))
    (error 'bench "Cannot mix suite names (all, mpl, shootout, racket) with individual benchmark names"))

  ;; Print header
  (newline)
  (cond
    [(quick-mode)
     (printf "Parbench (quick mode)~n")]
    [(quiet-mode)
     ;; Default quiet mode - minimal header
     (printf "Parbench~n")]
    [else
     ;; Verbose mode - show full details
     (printf "========================================~n")
     (printf "  Parbench - Parallel Benchmark Suite~n")
     (printf "========================================~n~n")
     (printf "Benchmarks:    ~a~n" (string-join items " "))
     (printf "Iterations:    ~a~n" (iterations))
     (printf "Worker counts: ~a~n" workers)
     (when (save-results)
       (printf "Output dir:    ~a~n" output-dir))
     (printf "Detected cores: ~a~n" (detect-cores))])
  (newline)

  ;; Track suite directories for HTML report
  (define suite-dirs '())

  (cond
    ;; Running suites
    [(not (null? suites))
     (for ([item suites])
       (case (string->symbol item)
         [(all)
          (run-suite 'mpl (build-path output-dir "mpl") workers)
          (set! suite-dirs (cons (build-path output-dir "mpl") suite-dirs))
          (newline)
          (run-suite 'shootout (build-path output-dir "shootout") workers)
          (set! suite-dirs (cons (build-path output-dir "shootout") suite-dirs))
          (newline)
          (run-suite 'racket (build-path output-dir "racket") workers)
          (set! suite-dirs (cons (build-path output-dir "racket") suite-dirs))]
         [(mpl shootout racket)
          (define suite (string->symbol item))
          (define dir (build-path output-dir item))
          (run-suite suite dir workers)
          (set! suite-dirs (cons dir suite-dirs))]))]

    ;; Running individual benchmarks
    [else
     ;; Group by suite
     (define grouped (make-hash))
     (for ([bench benchmarks])
       (define suite (get-benchmark-suite bench))
       (unless suite
         (error 'bench "Unknown benchmark: ~a~nRun 'racket bench.rkt --list' to see available benchmarks" bench))
       (hash-update! grouped suite (λ (lst) (cons bench lst)) '()))

     (for ([(suite bench-list) (in-hash grouped)])
       (define dir (build-path output-dir (suite->directory suite)))
       (make-directory* dir)
       (printf "Running ~a benchmarks...~n" suite)
       (for ([bench (reverse bench-list)])
         (run-benchmark (string->symbol bench) suite dir workers))
       (set! suite-dirs (cons dir suite-dirs)))])

  ;; Generate HTML report
  (when (generate-html)
    (newline)
    (define title
      (cond
        [(member "all" suites) "All Benchmarks"]
        [(not (null? suites))
         (string-join (map (λ (s) (format "~a Benchmarks" (string-titlecase s))) suites) " + ")]
        [else
         (format "Selected Benchmarks: ~a" (string-join benchmarks ", "))]))
    (generate-combined-report output-dir
                              (build-path output-dir "results.html")
                              title
                              (reverse suite-dirs)))

  ;; Always print results summary (unless dry-run)
  (unless (dry-run-mode)
    (print-results-summary workers))

  ;; Show file location if saving
  (when (save-results)
    (cond
      [(or (quick-mode) (quiet-mode))
       (printf "Results: ~a/results.html~n" output-dir)]
      [else
       (printf "Results saved to: ~a/~n" output-dir)
       (when (generate-html)
         (printf "View: open ~a/results.html~n" output-dir))])))
